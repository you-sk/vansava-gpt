<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mini Vampire Survivors Clone</title>
    <style>
        body { margin: 0; overflow: hidden; background: #222; color: white; font-family: sans-serif; }
        canvas { display: block; margin: 0 auto; background: #333; }
        #ui { position: absolute; top: 10px; left: 10px; }
        button { margin: 5px; padding: 10px; }
    </style>
</head>
<body>
    <div id="ui">
        <button id="startButton">Start Game</button>
        <button id="retryButton" style="display:none;">Retry</button>
        <div id="status"></div>
    </div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        let player, enemies, bullets, expOrbs, keys, gameRunning, lastTime, shootCooldown, elapsedTime, nextUpgradeTime;

        const playerSpeed = 3;
        const enemySpeed = 1.5;
        const bulletSpeed = 4;
        let shootInterval = 300;

        function startGame() {
            player = { x: 400, y: 300, size: 10, exp: 0, level: 1, expToLevelUp: 5 };
            enemies = [];
            bullets = [];
            expOrbs = [];
            keys = {};
            gameRunning = true;
            lastTime = 0;
            shootCooldown = 0;
            elapsedTime = 0;
            nextUpgradeTime = 10;

            document.getElementById('startButton').style.display = 'none';
            document.getElementById('retryButton').style.display = 'none';
            document.getElementById('status').innerText = '';

            requestAnimationFrame(gameLoop);
        }

        function gameLoop(timestamp) {
            if (!gameRunning) return;

            let delta = timestamp - lastTime;
            lastTime = timestamp;
            elapsedTime += delta / 1000;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            if (keys['ArrowUp']) player.y -= playerSpeed;
            if (keys['ArrowDown']) player.y += playerSpeed;
            if (keys['ArrowLeft']) player.x -= playerSpeed;
            if (keys['ArrowRight']) player.x += playerSpeed;

            player.x = Math.max(0, Math.min(canvas.width, player.x));
            player.y = Math.max(0, Math.min(canvas.height, player.y));

            if (shootCooldown <= 0) {
                for (let i = 0; i < 8; i++) {
                    let angle = (Math.PI * 2 / 8) * i;
                    bullets.push({ x: player.x, y: player.y, size: 5, angle: angle });
                }
                shootCooldown = shootInterval;
            } else {
                shootCooldown -= delta;
            }

            bullets.forEach(b => {
                b.x += bulletSpeed * Math.cos(b.angle);
                b.y += bulletSpeed * Math.sin(b.angle);
            });

            bullets = bullets.filter(b => !b.hit && b.x > 0 && b.x < canvas.width && b.y > 0 && b.y < canvas.height);

            if (Math.random() < 0.02) {
                let edge = Math.floor(Math.random() * 4);
                let ex, ey;
                if (edge === 0) { ex = Math.random() * canvas.width; ey = -20; }
                else if (edge === 1) { ex = Math.random() * canvas.width; ey = canvas.height + 20; }
                else if (edge === 2) { ex = -20; ey = Math.random() * canvas.height; }
                else { ex = canvas.width + 20; ey = Math.random() * canvas.height; }
                enemies.push({ x: ex, y: ey, size: 10, hp: 3 });
            }

            enemies.forEach(e => {
                let dx = player.x - e.x;
                let dy = player.y - e.y;
                let dist = Math.hypot(dx, dy);
                e.x += (dx / dist) * enemySpeed;
                e.y += (dy / dist) * enemySpeed;
            });

            bullets.forEach(b => {
                enemies.forEach(e => {
                    if (Math.hypot(e.x - b.x, e.y - b.y) < e.size + b.size) {
                        e.hp--;
                        b.hit = true;
                    }
                });
            });

            bullets = bullets.filter(b => !b.hit && b.x > 0 && b.x < canvas.width && b.y > 0 && b.y < canvas.height);

            enemies = enemies.filter(e => {
                if (e.hp <= 0) {
                    expOrbs.push({ x: e.x, y: e.y, size: 5 });
                    return false;
                }
                if (Math.hypot(e.x - player.x, e.y - player.y) < e.size + player.size) {
                    endGame();
                    return false;
                }
                return true;
            });

            expOrbs.forEach(o => {
                let dx = player.x - o.x;
                let dy = player.y - o.y;
                let dist = Math.hypot(dx, dy);
                if (dist < 10) {
                    player.exp++;
                    o.collected = true;
                } else {
                    o.x += (dx / dist) * 10.0;
                    o.y += (dy / dist) * 10.0;
                }
            });

            expOrbs = expOrbs.filter(o => !o.collected);

            if (player.exp >= player.expToLevelUp) {
                player.level++;
                player.exp = 0;
                player.expToLevelUp += 5;
                shootInterval = Math.max(100, shootInterval - 50);
            }

            ctx.fillStyle = 'lime';
            ctx.beginPath();
            ctx.arc(player.x, player.y, player.size, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = 'yellow';
            bullets.forEach(b => {
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.size, 0, Math.PI * 2);
                ctx.fill();
            });

            enemies.forEach(e => {
                ctx.fillStyle = 'red';
                ctx.beginPath();
                ctx.arc(e.x, e.y, e.size, 0, Math.PI * 2);
                ctx.fill();

                ctx.fillStyle = 'white';
                ctx.fillRect(e.x - 10, e.y - 15, 20, 3);
                ctx.fillStyle = 'green';
                ctx.fillRect(e.x - 10, e.y - 15, (20 * e.hp) / 3, 3);
            });

            ctx.fillStyle = 'cyan';
            expOrbs.forEach(o => {
                ctx.beginPath();
                ctx.arc(o.x, o.y, o.size, 0, Math.PI * 2);
                ctx.fill();
            });

            document.getElementById('status').innerText = `Time Survived: ${Math.floor(elapsedTime)} sec | Level: ${player.level} | EXP: ${player.exp}/${player.expToLevelUp}`;

            requestAnimationFrame(gameLoop);
        }

        function endGame() {
            gameRunning = false;
            document.getElementById('status').innerText += ' - GAME OVER';
            document.getElementById('retryButton').style.display = 'inline-block';
        }

        window.addEventListener('keydown', e => keys[e.key] = true);
        window.addEventListener('keyup', e => keys[e.key] = false);

        document.getElementById('startButton').addEventListener('click', startGame);
        document.getElementById('retryButton').addEventListener('click', startGame);
    </script>
</body>
</html>